# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tMvGXgb1FOnO9PNNnpcbJWvqWtb0ZUHT
"""

import pandas as pd
import numpy as np
import xgboost as xgb
from sklearn.model_selection import KFold, cross_val_score
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer

# --------------------------------------------------------------------------------
# 1. 데이터 로드 (수정됨: 하나의 엑셀 파일에서 시트별 로드)
# --------------------------------------------------------------------------------

# 엑셀 파일 경로 (Colab에 업로드한 파일명)
file_path = 'data_final.xlsx'

# 엑셀 파일 읽기 (sheet_name으로 시트 지정, header=1은 2번째 행이 변수명임을 의미)
# openpyxl 라이브러리가 필요할 수 있습니다 (Colab에는 기본 설치되어 있음)
df_us = pd.read_excel(file_path, sheet_name='초음파지표', header=1)
df_demo = pd.read_excel(file_path, sheet_name='Demographic data', header=1)

# 컬럼명 앞뒤 공백 제거
df_us.columns = df_us.columns.str.strip()
df_demo.columns = df_demo.columns.str.strip()

# 엑셀 열 알파벳을 인덱스로 변환하는 함수 (A=0, B=1, ..., AA=26)
def excel_col_to_index(col_str):
    col_str = col_str.upper()
    expn = 0
    col_num = 0
    for char in reversed(col_str):
        col_num += (ord(char) - ord('A') + 1) * (26 ** expn)
        expn += 1
    return col_num - 1

# 데이터를 추출하는 헬퍼 함수
def get_data_by_col_letter(sheet_name, col_letter):
    col_idx = excel_col_to_index(col_letter)

    if sheet_name == '초음파지표':
        if col_idx >= len(df_us.columns):
            raise ValueError(f"초음파지표 시트에는 {col_letter}열이 존재하지 않습니다.")
        col_name = df_us.columns[col_idx]
        return df_us[['No', col_name]].copy(), col_name

    elif sheet_name == 'Demographic data':
        if col_idx >= len(df_demo.columns):
            raise ValueError(f"Demographic data 시트에는 {col_letter}열이 존재하지 않습니다.")
        col_name = df_demo.columns[col_idx]
        return df_demo[['No', col_name]].copy(), col_name

    else:
        raise ValueError("시트 이름은 '초음파지표' 또는 'Demographic data'여야 합니다.")

# --------------------------------------------------------------------------------
# 2. 모델 설정 (★ 사용자가 수정하는 부분 ★)
# --------------------------------------------------------------------------------
# 각 종속변수(Target) 별로 사용할 독립변수(Features)를 입력하세요.
# 입력 형식: ('시트이름', '열알파벳')

models_config = {
    # 1. Bayley - 인지 (B열)
    "Model 1 (Bayley-Cognitive)": {
        "target_sheet": "Demographic data",
        "target_col": "B",
        "features": [
            # 예시: 초음파지표의 B열, C열과 Demographic data의 J열(재태주수)을 사용
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'R'),
            ('Demographic data', 'S'),
            ('Demographic data', 'AD'),
            # 여기에 필요한 변수를 계속 추가하세요
        ]
    },

    # 2. Bayley - 언어 (C열)
    "Model 2 (Bayley-Language)": {
        "target_sheet": "Demographic data",
        "target_col": "C",
        "features": [
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'P'),
            ('Demographic data', 'R'),
            ('Demographic data', 'S'),
            ('Demographic data', 'AD'),
        ]
    },

    # 3. Bayley - 운동 (D열)
    "Model 3 (Bayley-Motor)": {
        "target_sheet": "Demographic data",
        "target_col": "D",
        "features": [
             ('초음파지표', 'M'),
             ('초음파지표', 'Q'),
             ('Demographic data', 'J'),
             ('Demographic data', 'K'),
             ('Demographic data', 'L'),
             ('Demographic data', 'S'),
             ('Demographic data', 'AD'),
        ]
    },

    # 4. Bayley - 사회 정서 (E열)
    "Model 4 (Bayley-SocialEmotional)": {
        "target_sheet": "Demographic data",
        "target_col": "E",
        "features": [
            ('초음파지표', 'S'),
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'S'),
            ('Demographic data', 'AC'),
        ]
    },

    # 5. Bayley - 적응행동 (F열)
    "Model 5 (Bayley-AdaptiveBehavior)": {
        "target_sheet": "Demographic data",
        "target_col": "F",
        "features": [
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'R'),
            ('Demographic data', 'S'),
            ('Demographic data', 'AC'),
            ('Demographic data', 'AD'),
        ]
    },

    # 6. K-M-B CDI 표현낱말수 (G열)
    "Model 6 (K-M-B CDI Word Count)": {
        "target_sheet": "Demographic data",
        "target_col": "G",
        "features": [
            ('초음파지표', 'AI'),
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'R'),
            ('Demographic data', 'S'),
            ('Demographic data', 'X'),
        ]
    },

    # 7. K-M-B CDI 문법사용 (H열)
    "Model 7 (K-M-B CDI Grammar)": {
        "target_sheet": "Demographic data",
        "target_col": "H",
        "features": [
            ('초음파지표', 'M'),
            ('초음파지표', 'S'),
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'R'),
            ('Demographic data', 'S'),
            ('Demographic data', 'Y'),
        ]
    },

    # 8. M-CHAT-R 점수 (I열)
    "Model 8 (M-CHAT-R Score)": {
        "target_sheet": "Demographic data",
        "target_col": "I",
        "features": [
            ('초음파지표', 'M'),
            ('Demographic data', 'J'),
            ('Demographic data', 'K'),
            ('Demographic data', 'L'),
            ('Demographic data', 'Q'),
            ('Demographic data', 'R'),
            ('Demographic data', 'S'),
            ('Demographic data', 'T'),
            ('Demographic data', 'X'),
            ('Demographic data', 'AA'),
        ]
    }
}

# --------------------------------------------------------------------------------
# 3. 모델 학습 및 평가 루프
# --------------------------------------------------------------------------------

print(">>> XGBoost 모델 학습 시작 (5-Fold CV)\n")

for model_name, config in models_config.items():
    print(f"--- {model_name} 분석 중 ---")

    # 1) 종속변수(Target) 가져오기
    try:
        df_target, target_name = get_data_by_col_letter(config['target_sheet'], config['target_col'])
    except Exception as e:
        print(f"오류 발생 (Target 로드 중): {e}")
        continue

    # 2) 독립변수(Features) 가져오기 및 병합
    df_features = pd.DataFrame({'No': df_us['No']}) # 기준이 되는 환자 번호
    feature_names = []

    for sheet, col in config['features']:
        try:
            temp_df, col_name = get_data_by_col_letter(sheet, col)
            # 중복 컬럼명 방지 (시트명 접두사 붙이기 등 고려 가능하나 여기선 원본 이름 유지)
            # 만약 같은 이름의 변수가 다른 시트에 있다면 suffixes 처리됨
            df_features = pd.merge(df_features, temp_df, on='No', how='left')
            feature_names.append(col_name)
        except Exception as e:
            print(f"  [경고] 변수 로드 실패 ({sheet} - {col}): {e}")

    # 3) 전체 데이터 병합 (Target + Features)
    data_final = pd.merge(df_target, df_features, on='No', how='inner')

    # 4) 결측치 처리
    # Target(종속변수)에 결측치가 있는 행 제거 (G, H, I열 등)
    original_len = len(data_final)
    data_final = data_final.dropna(subset=[target_name])
    dropped_len = original_len - len(data_final)

    if len(data_final) < 5:
        print(f"  [Error] 데이터가 너무 적어 학습할 수 없습니다 (n={len(data_final)}). Target 결측치를 확인하세요.\n")
        continue

    print(f"  * 학습 데이터 수: {len(data_final)}명 (결측 제외됨: {dropped_len}명)")
    print(f"  * 종속변수: {target_name}")
    print(f"  * 독립변수({len(feature_names)}개): {feature_names}")

    # 5) X, y 분리
    X = data_final.drop(columns=['No', target_name])
    y = data_final[target_name]

    # 범주형 데이터 처리 (Demographic data의 경우 문자가 섞여있을 수 있음)
    # 수치형 변수와 범주형 변수 자동 구분
    numeric_features = X.select_dtypes(include=['int64', 'float64']).columns
    categorical_features = X.select_dtypes(include=['object', 'category']).columns

    # 전처리 파이프라인 설정
    # 수치형: 결측치 평균 대치 (혹은 XGBoost가 알아서 처리하게 둠)
    # 범주형: One-Hot Encoding
    preprocessor = ColumnTransformer(
        transformers=[
            ('num', SimpleImputer(strategy='mean'), numeric_features),
            ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_features)
        ])

    # XGBoost 모델 정의
    xgb_model = xgb.XGBRegressor(
        objective='reg:squarederror',
        n_estimators=100,
        learning_rate=0.1,
        max_depth=5,
        random_state=42,
        n_jobs=-1
    )

    # 파이프라인 생성 (전처리 -> 모델)
    model_pipeline = Pipeline(steps=[('preprocessor', preprocessor),
                                     ('model', xgb_model)])

    # 6) 5-Fold Cross Validation 수행
    kf = KFold(n_splits=5, shuffle=True, random_state=42)

    # 평가 지표: Negative MSE (sklearn은 loss를 음수로 반환함) -> RMSE로 변환 필요
    neg_mse_scores = cross_val_score(model_pipeline, X, y, cv=kf, scoring='neg_mean_squared_error')
    r2_scores = cross_val_score(model_pipeline, X, y, cv=kf, scoring='r2')

    rmse_scores = np.sqrt(-neg_mse_scores)

    # 7) 결과 출력
    print(f"  > 5-Fold CV 결과:")
    print(f"    - 평균 RMSE: {np.mean(rmse_scores):.4f} (± {np.std(rmse_scores):.4f})")
    print(f"    - 평균 R2 Score: {np.mean(r2_scores):.4f}")
    print("\n" + "="*80 + "\n")

